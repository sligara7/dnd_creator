"""
D&D 5e 2024 Creature Creation Module with LLM Integration.
Comprehensive creature generation following D&D 5e 2024 stat block format.
Uses shared components to eliminate code duplication.
"""
D&D 5e 2024 Creature Creation Module with LLM Integration.
Comprehensive creature generation following D&D 5e 2024 stat block format.
Uses shared components to eliminate code duplication.
"""

import json
import logging
import time
from typing import Dict, Any, List, Optional, Union
from dataclasses import dataclass
from enum import Enum

# Import shared components to eliminate duplication
from shared_character_generation import (
    CreationConfig, CreationResult, CharacterDataGenerator, 
    CharacterValidator, create_specialized_prompt
)

"""
D&D 5e 2024 Creature Creation Module with LLM Integration.
Comprehensive creature generation following D&D 5e 2024 stat block format.
Uses shared components to eliminate code duplication.
"""

import json
import logging
import time
from typing import Dict, Any, List, Optional, Union
from dataclasses import dataclass
from enum import Enum

# Import shared components to eliminate duplication
from shared_character_generation import (
    CreationConfig, CreationResult, CharacterDataGenerator, 
    CharacterValidator, create_specialized_prompt
)

# Import core D&D components
from core_models import AbilityScore, ProficiencyLevel
from character_models import DnDCondition
from llm_service_new import create_llm_service, LLMService
from database_models import CustomContent

logger = logging.getLogger(__name__)

# ============================================================================
# D&D 5E 2024 CREATURE DEFINITIONS
# ============================================================================

class CreatureType(Enum):
    """D&D 5e creature types."""
    ABERRATION = "aberration"
    BEAST = "beast"
    CELESTIAL = "celestial"
    CONSTRUCT = "construct"
    DRAGON = "dragon"
    ELEMENTAL = "elemental"
    FEY = "fey"
    FIEND = "fiend"
    GIANT = "giant"
    HUMANOID = "humanoid"
    MONSTROSITY = "monstrosity"
    OOZE = "ooze"
    PLANT = "plant"
    UNDEAD = "undead"

class CreatureSize(Enum):
    """D&D 5e creature sizes."""
    TINY = "Tiny"
    SMALL = "Small"
    MEDIUM = "Medium"
    LARGE = "Large"
    HUGE = "Huge"
    GARGANTUAN = "Gargantuan"

class CreatureAlignment(Enum):
    """D&D 5e alignments."""
    LAWFUL_GOOD = "lawful good"
    NEUTRAL_GOOD = "neutral good"
    CHAOTIC_GOOD = "chaotic good"
    LAWFUL_NEUTRAL = "lawful neutral"
    TRUE_NEUTRAL = "true neutral"
    CHAOTIC_NEUTRAL = "chaotic neutral"
    LAWFUL_EVIL = "lawful evil"
    NEUTRAL_EVIL = "neutral evil"
    CHAOTIC_EVIL = "chaotic evil"
    UNALIGNED = "unaligned"

# CreatureConfig and CreatureResult have been replaced with shared CreationConfig and CreationResult
# from shared_character_generation.py to eliminate code duplication

class CreatureCore:
    """
    D&D 5e 2024 Creature stat block implementation.
    Contains all attributes required for a complete creature definition.
    """
    
    def __init__(self, name: str):
        # Basic Information
        self.name = name
        self.size = CreatureSize.MEDIUM
        self.creature_type = CreatureType.HUMANOID
        self.alignment = CreatureAlignment.TRUE_NEUTRAL
        
        # Core Stats
        self.armor_class = 10
        self.hit_points = 1
        self.hit_dice = "1d8"
        self.speed = {"walk": 30}  # Can include fly, swim, climb, burrow
        
        # Ability Scores (D&D 5e standard)
        self.strength = AbilityScore(10)
        self.dexterity = AbilityScore(10)
        self.constitution = AbilityScore(10)
        self.intelligence = AbilityScore(10)
        self.wisdom = AbilityScore(10)
        self.charisma = AbilityScore(10)
        
        # Proficiencies
        self.saving_throws: Dict[str, int] = {}
        self.skills: Dict[str, int] = {}
        
        # Resistances and Immunities
        self.damage_vulnerabilities: List[str] = []
        self.damage_resistances: List[str] = []
        self.damage_immunities: List[str] = []
        self.condition_immunities: List[DnDCondition] = []
        
        # Senses
        self.senses = {
            "passive_perception": 10,
            "darkvision": 0,
            "blindsight": 0,
            "tremorsense": 0,
            "truesight": 0
        }
        
        # Languages
        self.languages: List[str] = []
        
        # Challenge Rating
        self.challenge_rating = 1.0
        self.proficiency_bonus = 2
        
        # 2024 Stat Block Sections
        self.special_traits: List[Dict[str, Any]] = []
        self.actions: List[Dict[str, Any]] = []
        self.bonus_actions: List[Dict[str, Any]] = []
        self.reactions: List[Dict[str, Any]] = []
        self.legendary_actions: List[Dict[str, Any]] = []
        self.lair_actions: List[Dict[str, Any]] = []
        
        # 2024 New Sections
        self.gear: List[str] = []
        self.habitat: List[str] = []
        self.treasure: Dict[str, Any] = {}
        
        # Spellcasting
        self.innate_spellcasting: Optional[Dict[str, Any]] = None
        self.spellcasting: Optional[Dict[str, Any]] = None
        
        # Metadata
        self.description = ""
        self.lore = ""
        self.tactics = ""
    
    def calculate_derived_stats(self):
        """Calculate derived statistics from ability scores."""
        # Update proficiency bonus based on CR
        self.proficiency_bonus = max(2, 2 + int((self.challenge_rating - 1) // 4))
        
        # Update passive perception
        wisdom_mod = self.wisdom.modifier
        perception_bonus = self.skills.get("perception", 0)
        self.senses["passive_perception"] = 10 + wisdom_mod + perception_bonus
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert creature to dictionary format."""
        return {
            "name": self.name,
            "size": self.size.value,
            "type": self.creature_type.value,
            "alignment": self.alignment.value,
            "armor_class": self.armor_class,
            "hit_points": self.hit_points,
            "hit_dice": self.hit_dice,
            "speed": self.speed,
            "abilities": {
                "strength": self.strength.total_score,
                "dexterity": self.dexterity.total_score,
                "constitution": self.constitution.total_score,
                "intelligence": self.intelligence.total_score,
                "wisdom": self.wisdom.total_score,
                "charisma": self.charisma.total_score
            },
            "saving_throws": self.saving_throws,
            "skills": self.skills,
            "damage_vulnerabilities": self.damage_vulnerabilities,
            "damage_resistances": self.damage_resistances,
            "damage_immunities": self.damage_immunities,
            "condition_immunities": [c.value for c in self.condition_immunities],
            "senses": self.senses,
            "languages": self.languages,
            "challenge_rating": self.challenge_rating,
            "proficiency_bonus": self.proficiency_bonus,
            "special_traits": self.special_traits,
            "actions": self.actions,
            "bonus_actions": self.bonus_actions,
            "reactions": self.reactions,
            "legendary_actions": self.legendary_actions,
            "lair_actions": self.lair_actions,
            "gear": self.gear,
            "habitat": self.habitat,
            "treasure": self.treasure,
            "innate_spellcasting": self.innate_spellcasting,
            "spellcasting": self.spellcasting,
            "description": self.description,
            "lore": self.lore,
            "tactics": self.tactics
        }


class CreatureCreator:
    """
    D&D 5e 2024 Creature Creation Service with LLM Integration.
    Generates complete stat blocks following D&D 5e 2024 format.
    Uses shared components to eliminate code duplication.
    """
    
    def __init__(self, llm_service: Optional[LLMService] = None, 
                 config: Optional[CreationConfig] = None):
        self.llm_service = llm_service or create_llm_service()
        self.config = config or CreationConfig()
        
        # Initialize shared components
        self.validator = CharacterValidator()
        self.data_generator = CharacterDataGenerator(self.llm_service, self.config)
        
        logger.info("CreatureCreator initialized with shared components")
    
    def create_creature(self, description: str, challenge_rating: float = 1.0,
                       creature_type: Optional[str] = None,
                       size: Optional[str] = None) -> CreationResult:
        """
        Create a complete D&D 5e 2024 creature from description.
        
        Args:
            description: Natural language description of the creature
            challenge_rating: Desired CR (0.125 to 30+)
            creature_type: Optional creature type override
            size: Optional size override
        """
        start_time = time.time()
        
        try:
            # Generate creature using LLM if available
            if self.config.use_llm_generation and self.llm_service:
                creature_data = self._generate_with_llm(
                    description, challenge_rating, creature_type, size
                )
                llm_used = True
            else:
                creature_data = self._generate_basic_creature(
                    description, challenge_rating, creature_type, size
                )
                llm_used = False
            
            # Create CreatureCore from generated data
            creature = self._build_creature_core(creature_data)
            
            # Calculate derived statistics
            creature.calculate_derived_stats()
            
            # Validate the creature
            validation_result = self._validate_creature(creature)
            
            result = CreatureResult(
                success=True, 
                creature_data=creature.to_dict()
            )
            result.warnings.extend(validation_result.get("warnings", []))
            result.creation_time = time.time() - start_time
            result.llm_generation_used = llm_used
            
            logger.info(f"Created creature '{creature.name}' (CR {creature.challenge_rating}) in {result.creation_time:.2f}s")
            return result
            
        except Exception as e:
            logger.error(f"Failed to create creature: {e}")
            result = CreatureResult(error=str(e))
            result.creation_time = time.time() - start_time
            return result
    
    def _generate_with_llm(self, description: str, challenge_rating: float,
                          creature_type: Optional[str], size: Optional[str]) -> Dict[str, Any]:
        """Generate creature using LLM service."""
        prompt = self._build_creature_prompt(description, challenge_rating, creature_type, size)
        
        try:
            response = self.llm_service.generate_content(prompt)
            
            # Clean and parse JSON response
            cleaned_response = self._clean_json_response(response)
            creature_data = json.loads(cleaned_response)
            
            return creature_data
            
        except Exception as e:
            logger.warning(f"LLM generation failed: {e}. Falling back to basic generation.")
            return self._generate_basic_creature(description, challenge_rating, creature_type, size)
    
    def _generate_basic_creature(self, description: str, challenge_rating: float,
                                creature_type: Optional[str], size: Optional[str]) -> Dict[str, Any]:
        """Generate basic creature without LLM."""
        # Extract name from description or use default
        name = self._extract_name_from_description(description) or "Unknown Creature"
        
        # Use CR-based scaling for basic stats
        hp_base = max(1, int(challenge_rating * 15))
        ac_base = max(10, int(10 + challenge_rating // 2))
        
        return {
            "name": name,
            "size": size or "Medium",
            "type": creature_type or "humanoid",
            "alignment": "neutral",
            "armor_class": ac_base,
            "hit_points": hp_base,
            "hit_dice": f"{max(1, hp_base // 6)}d8",
            "speed": {"walk": 30},
            "abilities": {
                "strength": min(20, max(8, 10 + int(challenge_rating))),
                "dexterity": min(20, max(8, 10 + int(challenge_rating // 2))),
                "constitution": min(20, max(8, 10 + int(challenge_rating))),
                "intelligence": 10,
                "wisdom": 12,
                "charisma": 10
            },
            "challenge_rating": challenge_rating,
            "description": description,
            "actions": [
                {
                    "name": "Basic Attack",
                    "description": f"Melee Weapon Attack: +{2 + int(challenge_rating)} to hit, reach 5 ft., one target. Hit: {max(1, int(4 + challenge_rating))} damage."
                }
            ]
        }
    
    def _build_creature_core(self, creature_data: Dict[str, Any]) -> CreatureCore:
        """Build CreatureCore from generated data."""
        creature = CreatureCore(creature_data.get("name", "Unknown Creature"))
        
        # Set basic properties
        if "size" in creature_data:
            try:
                creature.size = CreatureSize(creature_data["size"].title())
            except ValueError:
                pass
        
        if "type" in creature_data:
            try:
                creature.creature_type = CreatureType(creature_data["type"].lower())
            except ValueError:
                pass
        
        if "alignment" in creature_data:
            try:
                creature.alignment = CreatureAlignment(creature_data["alignment"].lower())
            except ValueError:
                pass
        
        # Set core stats
        creature.armor_class = creature_data.get("armor_class", 10)
        creature.hit_points = creature_data.get("hit_points", 1)
        creature.hit_dice = creature_data.get("hit_dice", "1d8")
        creature.speed = creature_data.get("speed", {"walk": 30})
        creature.challenge_rating = creature_data.get("challenge_rating", 1.0)
        
        # Set ability scores
        abilities = creature_data.get("abilities", {})
        creature.strength.base_score = abilities.get("strength", 10)
        creature.dexterity.base_score = abilities.get("dexterity", 10)
        creature.constitution.base_score = abilities.get("constitution", 10)
        creature.intelligence.base_score = abilities.get("intelligence", 10)
        creature.wisdom.base_score = abilities.get("wisdom", 10)
        creature.charisma.base_score = abilities.get("charisma", 10)
        
        # Set additional properties
        creature.saving_throws = creature_data.get("saving_throws", {})
        creature.skills = creature_data.get("skills", {})
        creature.senses.update(creature_data.get("senses", {}))
        creature.languages = creature_data.get("languages", [])
        
        # Set stat block sections
        creature.special_traits = creature_data.get("special_traits", [])
        creature.actions = creature_data.get("actions", [])
        creature.bonus_actions = creature_data.get("bonus_actions", [])
        creature.reactions = creature_data.get("reactions", [])
        creature.legendary_actions = creature_data.get("legendary_actions", [])
        
        # Set 2024 additions
        creature.gear = creature_data.get("gear", [])
        creature.habitat = creature_data.get("habitat", [])
        creature.treasure = creature_data.get("treasure", {})
        
        # Set descriptive content
        creature.description = creature_data.get("description", "")
        creature.lore = creature_data.get("lore", "")
        creature.tactics = creature_data.get("tactics", "")
        
        return creature
    
    def _build_creature_prompt(self, description: str, challenge_rating: float,
                              creature_type: Optional[str], size: Optional[str]) -> str:
        """Build LLM prompt for creature generation."""
        return f"""Create a complete D&D 5e 2024 creature stat block for the following:

Description: {description}
Challenge Rating: {challenge_rating}
{f"Creature Type: {creature_type}" if creature_type else ""}
{f"Size: {size}" if size else ""}

Generate a complete JSON stat block following D&D 5e 2024 format including:

1. Basic Info: name, size, type, alignment
2. Core Stats: AC, HP, hit dice, speed
3. Ability Scores: STR, DEX, CON, INT, WIS, CHA (3-30 range)
4. Proficiencies: saving throws, skills
5. Resistances/Immunities: damage and condition immunities
6. Senses: passive perception, special senses
7. Languages: list of known languages
8. Special Traits: unique abilities and features
9. Actions: attacks and special actions
10. Bonus Actions, Reactions: if applicable
11. Legendary Actions: if CR 5+ and appropriate
12. 2024 Additions: gear, habitat, treasure
13. Spellcasting: if applicable

Ensure the creature is balanced for CR {challenge_rating} and follows D&D 5e 2024 design guidelines.

Return only valid JSON without code blocks or markdown."""
    
    def _validate_creature(self, creature: CreatureCore) -> Dict[str, Any]:
        """Validate creature stat block for balance and completeness."""
        warnings = []
        
        # CR validation
        if creature.challenge_rating < 0.125 or creature.challenge_rating > 30:
            warnings.append(f"Unusual challenge rating: {creature.challenge_rating}")
        
        # HP validation
        expected_hp = self._calculate_expected_hp(creature.challenge_rating)
        if abs(creature.hit_points - expected_hp) > expected_hp * 0.5:
            warnings.append(f"HP ({creature.hit_points}) unusual for CR {creature.challenge_rating}")
        
        # Ability score validation
        for ability_name in ["strength", "dexterity", "constitution", "intelligence", "wisdom", "charisma"]:
            ability = getattr(creature, ability_name)
            if ability.total_score < 1 or ability.total_score > 30:
                warnings.append(f"{ability_name.title()} score out of range: {ability.total_score}")
        
        # Actions validation
        if not creature.actions:
            warnings.append("Creature has no actions defined")
        
        return {"valid": True, "warnings": warnings}
    
    def _calculate_expected_hp(self, challenge_rating: float) -> int:
        """Calculate expected HP for a given CR (rough approximation)."""
        if challenge_rating <= 0.25:
            return 7
        elif challenge_rating <= 0.5:
            return 22
        elif challenge_rating <= 1:
            return 33
        elif challenge_rating <= 2:
            return 58
        elif challenge_rating <= 4:
            return 116
        elif challenge_rating <= 10:
            return int(challenge_rating * 75)
        else:
            return int(challenge_rating * 100)
    
    def _extract_name_from_description(self, description: str) -> Optional[str]:
        """Extract creature name from description."""
        # Simple extraction - look for capitalized words at start
        words = description.split()
        if words:
            # Take first 1-3 capitalized words as potential name
            name_words = []
            for word in words[:3]:
                if word and word[0].isupper():
                    name_words.append(word)
                else:
                    break
            if name_words:
                return " ".join(name_words)
        return None
    
    def _clean_json_response(self, response: str) -> str:
        """Clean LLM response to extract valid JSON."""
        # Remove code blocks and markdown
        response = response.strip()
        if response.startswith("```"):
            lines = response.split("\n")
            start_idx = 1 if lines[0].startswith("```") else 0
            end_idx = len(lines)
            for i, line in enumerate(lines[start_idx:], start_idx):
                if line.strip() == "```":
                    end_idx = i
                    break
            response = "\n".join(lines[start_idx:end_idx])
        
        # Find JSON content
        start_idx = response.find("{")
        end_idx = response.rfind("}") + 1
        if start_idx != -1 and end_idx > start_idx:
            response = response[start_idx:end_idx]
        
        return response
    
    def get_creature_templates(self) -> Dict[str, Dict[str, Any]]:
        """Get creature templates for common creature types."""
        return {
            "goblin": {
                "name": "Goblin",
                "size": "Small",
                "type": "humanoid",
                "alignment": "neutral evil",
                "challenge_rating": 0.25,
                "armor_class": 15,
                "hit_points": 7,
                "hit_dice": "2d6",
                "abilities": {"strength": 8, "dexterity": 14, "constitution": 10, "intelligence": 10, "wisdom": 8, "charisma": 8}
            },
            "orc": {
                "name": "Orc",
                "size": "Medium", 
                "type": "humanoid",
                "alignment": "chaotic evil",
                "challenge_rating": 1.0,
                "armor_class": 13,
                "hit_points": 15,
                "hit_dice": "2d8+2",
                "abilities": {"strength": 16, "dexterity": 12, "constitution": 13, "intelligence": 7, "wisdom": 11, "charisma": 10}
            },
            "young_dragon": {
                "name": "Young Red Dragon",
                "size": "Large",
                "type": "dragon", 
                "alignment": "chaotic evil",
                "challenge_rating": 10.0,
                "armor_class": 18,
                "hit_points": 178,
                "hit_dice": "17d12+68",
                "abilities": {"strength": 23, "dexterity": 10, "constitution": 19, "intelligence": 14, "wisdom": 11, "charisma": 19}
            }
        }


# ============================================================================
# CONVENIENCE FUNCTIONS
# ============================================================================

def create_creature(description: str, challenge_rating: float = 1.0,
                   creature_type: Optional[str] = None,
                   size: Optional[str] = None,
                   llm_service: Optional[LLMService] = None) -> CreatureResult:
    """Convenience function to create a creature."""
    creator = CreatureCreator(llm_service)
    return creator.create_creature(description, challenge_rating, creature_type, size)

def save_creature_to_database(creature_data: Dict[str, Any], 
                            db_session, created_by: str = "dm") -> Dict[str, Any]:
    """Save creature to database as custom content."""
    try:
        custom_content = CustomContent(
            name=creature_data.get("name", "Unknown Creature"),
            content_type="creature",
            content_data=creature_data,
            description=creature_data.get("description", ""),
            created_by=created_by,
            is_public=False
        )
        
        db_session.add(custom_content)
        db_session.commit()
        db_session.refresh(custom_content)
        
        return {
            "success": True,
            "creature_id": custom_content.id,
            "message": f"Creature '{creature_data['name']}' saved successfully"
        }
        
    except Exception as e:
        db_session.rollback()
        return {"success": False, "error": str(e)}
